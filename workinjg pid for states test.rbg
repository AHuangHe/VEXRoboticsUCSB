#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in3,    potentiometer,  sensorNone)
#pragma config(Sensor, in4,    light,          sensorNone)
#pragma config(Sensor, in6,    accelZ,         sensorNone)
#pragma config(Sensor, in7,    accelY,         sensorNone)
#pragma config(Sensor, in8,    accelX,         sensorNone)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorNone)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorNone)
#pragma config(Sensor, dgtl6,  frontTouch,     sensorNone)
#pragma config(Sensor, dgtl8,  sonarCM,        sensorNone)
#pragma config(Sensor, dgtl11, backTouch,      sensorNone)
#pragma config(Sensor, dgtl12, led,            sensorNone)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           roller,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           bar,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           intake,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LeftBase,      tmotorVex393HighSpeed_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port5,           LeftBase1,     tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port6,           RightBase,     tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port7,           RightBase1,    tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port8,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LeftArm,       tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_3)
#pragma config(Motor,  port10,          rightarm,      tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("Globals")
#pragma DebuggerWindows("Motors")

#pragma platform(VEX)

task
roryIsBae( ) {
	clearDebugStream( );
	while(true) {
		writeDebugStream("\n %i, %i", nMotorEncoder[LeftBase], nMotorEncoder[RightBase], nMotorEncoder[LeftArm], nMotorEncoder[RightArm]);
		delay( 20 ); //Don't hog the CPU!
	}
}



void moveBase (int speed)
{
	motor[LeftBase] = speed;
	motor[RightBase1] = speed;
	motor[LeftBase1] = speed;
	motor[RightBase] = speed;
}

void turnBase (int speed) // positive is clockwise
{
	motor[LeftBase] = speed;
	motor[LeftBase1] = speed;
	motor[RightBase] = -speed;
	motor[RightBase1] = -speed;
}

void armBase (int speed)
{
	motor[RightArm] = speed;
	motor[LeftArm] = speed;
}

int inchToTicks (float inch)
{
	int ticks;
	ticks = inch*99.82198;
	return ticks;
}

int fixTimerValue (float rawSeconds)
{
	int miliseconds;
	miliseconds = rawSeconds*1000;
	if (miliseconds < 250)
	{
		miliseconds = 250;
	}
	return miliseconds;
}

void PIDBaseControl (float target, float waitTime, float maxPower = 1)
{
	float Kp = 0.34;
	float Ki = 0.01;
	float Kd = 0.5;

	int error;

	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;

	float integralActiveZone = inchToTicks(3);
	float integralPowerLimit = 50/Ki;

	int finalPower;

	bool timerBool = true;

	nMotorEncoder[LeftBase] = 0;
	nMotorEncoder[RightBase] = 0;

	clearTimer(T1);

	while (time1[T1] < fixTimerValue(waitTime))
	{
		error = inchToTicks(target)-(-nMotorEncoder[LeftBase]-(nMotorEncoder[RightBase]));

		proportion = Kp*error;

		if (abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw+error;
		}
		else
		{
			integralRaw = 0;
		}

		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = -integralPowerLimit;
		}

		integral = Ki*integralRaw;

		derivative = Kd*(error-lastError);
		lastError = error;

		if (error == 0)
		{
			derivative = 0;
		}

		finalPower = proportion+integral+derivative;

		if (finalPower > maxPower*127)
		{
			finalPower = maxPower*127;
		}
		else if (finalPower < -maxPower*127)
		{
			finalPower = -maxPower*127;
		}

		moveBase(finalPower);

		wait1Msec(40);

		if (error < 30)
		{
			timerBool = false;
		}

		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	moveBase(0);
}

void PIDBaseTurn (int target, float waitTime, float maxPower = 1)
{
	float Kp = 0.35;
	float Ki = 0.04;
	float Kd = 0.5;

	int error;

	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;

	float integralActiveZone = inchToTicks(3);
	float integralPowerLimit = 50/Ki;

	int finalPower;

	bool timerBool = true;

	nMotorEncoder[LeftBase] = 0;
	nMotorEncoder[RightBase] = 0;

	clearTimer(T1);

	while (time1[T1] < fixTimerValue(waitTime))
	{
		error = target-(nMotorEncoder[LeftBase]+nMotorEncoder[RightBase]);

		proportion = Kp*error;

		if (abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw+error;
		}
		else
		{
			integralRaw = 0;
		}

		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = -integralPowerLimit;
		}

		integral = Ki*integralRaw;

		derivative = Kd*(error-lastError);
		lastError = error;

		if (error == 0)
		{
			derivative = 0;
		}

		finalPower = proportion+integral+derivative;

		if (finalPower > maxPower*127)
		{
			finalPower = maxPower*127;
		}
		else if (finalPower < -maxPower*127)
		{
			finalPower = -maxPower*127;
		}

		turnBase(finalPower);

		wait1Msec(40);

		if (error < 30)
		{
			timerBool = false;
		}

		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	turnBase(0);
}

void PIDArmControl (float target, float waitTime, float maxPower = 1)
{
	float Kp = 0.35;
	float Ki = 0.04;
	float Kd = 0.5;

	int error;

	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;

	float integralActiveZone = inchToTicks(3);
	float integralPowerLimit = 50/Ki;

	int finalPower;

	bool timerBool = true;

	nMotorEncoder[RightArm] = 0;
	nMotorEncoder[LeftArm] = 0;

	clearTimer(T1);

	while (time1[T1] < fixTimerValue(waitTime))
	{
		error = inchToTicks(target)-(-nMotorEncoder[LeftArm]);

		proportion = Kp*error;

		if (abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw+error;
		}
		else
		{
			integralRaw = 0;
		}

		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = -integralPowerLimit;
		}

		integral = Ki*integralRaw;

		derivative = Kd*(error-lastError);
		lastError = error;

		if (error == 0)
		{
			derivative = 0;
		}

		finalPower = proportion+integral+derivative;

		if (finalPower > maxPower*127)
		{
			finalPower = maxPower*127;
		}
		else if (finalPower < -maxPower*127)
		{
			finalPower = -maxPower*127;
		}

		armBase(finalPower);

		wait1Msec(40);

		if (error < 30)
		{
			timerBool = false;
		}

		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	armBase(0);
}

task main ()
{
	startTask(roryIsBae);
	motor[port1] = 40;
	PIDArmControl (1.35,.1);
	motor[port1] = 40;
	wait1Msec(10);
	motor[port1] = 40;
	motor[port3] = 90;
	motor[port8] = 90;
	PIDBaseControl(30,.1);
	wait1Msec(10);
	motor[port3] = 0;
	motor[port8] = 0;
	wait1Msec(5);
	motor[port3] = -127;
	motor[port8] = -127;
	wait1Msec(1500);
	motor[port3] = 0;
	motor[port8] = 0;
	wait1Msec(10);
	PIDArmControl(-1.35,.1);
	motor[port1] = -40;
	wait1Msec(100);
	PIDBaseControl(5,.1);
	motor[port1] = 40;
	motor[port2] = -127;
	wait1Msec(300);
	motor[port1] = 40;
	PIDArmControl(-6,.1);
	wait1Msec(10);
	motor[port9] = 0;
	motor[port10] = 0;
	wait1Msec(10);
	motor[port1] = 40;
	PIDArmControl(2,.1);
	wait1Msec(10);
	motor[port1] = 60;
	motor[port2] = 90;
	wait1Msec(1100);
	motor[port2] = 0;
	wait1Msec(100);
	PIDArmControl(-2,.1);
	motor[port1] = -127;
	wait1Msec(100);
	PIDArmControl(2,.1);
	PIDBaseControl(-20,1);
	motor[port1] = 0;
	wait1Msec(10);
	motor[port4] = 127;
	motor[port5] = 127;
	motor[port6] = -127;
	motor[port7] = -127;
	wait1Msec(1000);
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	wait1Msec(10);
	motor[port3] = 127;
	motor[port8] = 127;
	wait1Msec(600);
	motor[port3] = 0;
	motor[port8] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	wait1Msec(200);
	PIDBaseControl (-10,1);
	while(true)
	{
		wait1Msec(20);
	}
}
